<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Optimizing Geospatial Property Search - stawuah.r</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.7;
      color: #1a1a1a;
      background-color: #fff;
      padding: 0;
      margin: 0;
    }

    .container {
      max-width: 680px;
      margin: 0 auto;
      padding: 60px 20px 100px 20px;
    }

    .header {
      margin-bottom: 50px;
    }

    .header h1 {
      font-size: 1.4rem;
      font-weight: 600;
      margin-bottom: 8px;
      color: #000;
    }

    .header .breadcrumb {
      font-size: 0.9rem;
      color: #737373;
      margin-bottom: 30px;
    }

    .header .breadcrumb a {
      color: #737373;
      text-decoration: none;
    }

    .header .breadcrumb a:hover {
      color: #000;
    }

    nav {
      position: absolute;
      top: 60px;
      right: 60px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
    }

    nav a {
      color: #404040;
      text-decoration: none;
      font-size: 0.9rem;
      transition: color 0.2s;
    }

    nav a:hover {
      color: #000;
    }

    .article-title {
      font-size: 2.8rem;
      font-weight: 700;
      margin-bottom: 20px;
      color: #000;
      line-height: 1.2;
    }

    .article-meta {
      font-size: 0.95rem;
      color: #737373;
      margin-bottom: 50px;
    }

    .article-content {
      font-size: 1.05rem;
      color: #2a2a2a;
      line-height: 1.8;
    }

    .article-content h2 {
      font-size: 1.6rem;
      font-weight: 600;
      margin-top: 50px;
      margin-bottom: 20px;
      color: #000;
    }

    .article-content h3 {
      font-size: 1.3rem;
      font-weight: 600;
      margin-top: 35px;
      margin-bottom: 15px;
      color: #000;
    }

    .article-content p {
      margin-bottom: 25px;
    }

    .article-content a {
      color: #0066cc;
      text-decoration: none;
      border-bottom: 1px solid transparent;
    }

    .article-content a:hover {
      border-bottom: 1px solid #0066cc;
    }

    .article-content strong {
      color: #000;
      font-weight: 600;
    }

    .article-content ul {
      margin-bottom: 25px;
      padding-left: 25px;
    }

    .article-content ul li {
      margin-bottom: 10px;
    }

    .article-content pre {
      background-color: #f5f5f5;
      padding: 20px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 25px 0;
      border: 1px solid #e8e8e8;
    }

    .article-content code {
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
    }

    .article-content pre code {
      color: #2a2a2a;
      background: none;
      padding: 0;
    }

    .article-content :not(pre) > code {
      background-color: #f5f5f5;
      padding: 2px 6px;
      border-radius: 3px;
      color: #e83e8c;
    }

    .performance-table {
      width: 100%;
      border-collapse: collapse;
      margin: 30px 0;
      font-size: 0.95rem;
    }

    .performance-table th,
    .performance-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #e8e8e8;
    }

    .performance-table th {
      background-color: #f9f9f9;
      font-weight: 600;
      color: #000;
    }

    .performance-table tr:last-child td {
      border-bottom: none;
    }

    .footnote {
      font-size: 0.9rem;
      color: #737373;
      margin-top: 60px;
      padding-top: 30px;
      border-top: 1px solid #e8e8e8;
      font-style: italic;
    }

    @media (max-width: 768px) {
      nav {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background-color: #fff;
        border-bottom: 1px solid #e8e8e8;
        padding: 15px 20px;
        z-index: 100;
        flex-direction: row;
        justify-content: flex-start;
        gap: 16px;
      }

      .container {
        padding: 80px 20px 80px 20px;
      }

      .article-title {
        font-size: 2rem;
      }

      .article-content h2 {
        font-size: 1.4rem;
      }

      .article-content h3 {
        font-size: 1.2rem;
      }

      .article-content pre {
        padding: 15px;
        font-size: 0.85rem;
      }
    }
  </style>
</head>
<body>

<nav>
  <a href="index.html">home</a>
  <a href="about.html">about</a>
  <a href="writings.html">writings</a>
  <a href="projects.html">projects</a>
</nav>

<div class="container">
  <div class="header">
    <h1>Stephen Awuah</h1>
    <p class="breadcrumb"><a href="index.html">home</a> / <a href="writings.html">writings</a> / optimizing geospatial property search</p>
  </div>

  <h1 class="article-title">optimizing geospatial property search: from 10,000 queries to sub-second performance</h1>
  
  <div class="article-meta">January 22, 2026 • Stephen Awuah • 15 min read</div>

  <div class="article-content">
    <h2>The Problem</h2>
    <p>While building a real estate platform with location-based property notifications, I encountered a critical performance bottleneck. The initial implementation was simple but catastrophically inefficient:</p>

    <pre><code>// The naive approach - fetches EVERYTHING
const allProps = await db
  .select()
  .from(properties)
  .where(eq(properties.status, 'active'));

// Then filters 10,000+ properties in memory
const filtered = allProps.filter((p) => {
  const dist = haversine(userLat, userLon, p.latitude, p.longitude);
  return dist <= radius;
});</code></pre>

    <p>With 10,000+ active properties in the database, this meant:</p>
    <ul>
      <li>Loading every single property into memory</li>
      <li>Calculating haversine distance 10,000+ times per search</li>
      <li>Network overhead transferring massive datasets</li>
      <li>Response times of 2-5 seconds (unacceptable for modern web apps)</li>
    </ul>

    <h2>Understanding the Core Issues</h2>

    <h3>Issue 1: Database vs Application Filtering</h3>
    <p>The fundamental mistake was doing spatial filtering in the application layer. Databases are optimized for filtering data, but we were bypassing that entirely.</p>

    <h3>Issue 2: The TypeScript Type System Challenge</h3>
    <p>Our database schema used PostgreSQL's <code>NUMERIC</code> type for coordinates and prices, which TypeScript represents as strings. This created a conflict with our comparison operators:</p>

    <pre><code>// This fails - comparing PgNumeric (string) with number
gte(properties.latitude, minLat)  // ❌ Type error!

// This works - converting to string
gte(properties.latitude, minLat.toString())  // ✅</code></pre>

    <h3>Issue 3: Drizzle ORM Query Chaining</h3>
    <p>Unlike some ORMs, Drizzle doesn't support multiple <code>.where()</code> calls:</p>

    <pre><code>// This doesn't work
let query = db.select().from(properties);
query = query.where(eq(properties.status, 'active'));  // ❌
query = query.where(gte(properties.price, minPrice));  // ❌</code></pre>

    <p>You must combine all conditions into a single <code>where()</code> call using <code>and()</code>.</p>

    <h2>The Solution: Two-Stage Filtering</h2>
    <p>The optimization strategy uses a two-stage approach:</p>

    <h3>Stage 1: Bounding Box Filter (Database Level)</h3>
    <p>Instead of fetching all properties, we calculate a rectangular "bounding box" around the user's location and filter at the database level:</p>

    <pre><code>// Calculate bounding box
// 1 degree latitude ≈ 111 km
const latDelta = radius / 111;

// Longitude varies by latitude
const lonDelta = radius / (111 * Math.cos(userLat * Math.PI / 180));

const minLat = userLat - latDelta;
const maxLat = userLat + latDelta;
const minLon = userLon - lonDelta;
const maxLon = userLon + lonDelta;</code></pre>

    <p>This bounding box represents a rectangular area that's guaranteed to contain all properties within our circular radius (plus some extras at the corners).</p>

    <h3>Stage 2: Precise Circle Filter (Application Level)</h3>
    <p>After fetching the reduced dataset, we apply the precise haversine formula to filter to an exact circular radius:</p>

    <pre><code>const filtered = candidateProps.filter((p) => {
  const lat = parseFloat(p.latitude);
  const lon = parseFloat(p.longitude);
  const dist = haversine(userLat, userLon, lat, lon);
  return dist <= radius;
});</code></pre>

    <h2>The Complete Implementation</h2>
    <p>Here's the production-ready solution:</p>

    <pre><code>async findNearbyProperties(userId: number) {
  // Get user location and preferences
  const loc = await this.getUserLocation(userId);
  if (!loc) throw new Error('Location not set');
  
  const prefs = await this.getPreferences(userId);
  const radius = prefs?.radius ?? 5;
  const priceMin = prefs?.priceMin ?? 0;
  const priceMax = prefs?.priceMax ?? Number.MAX_SAFE_INTEGER;
  const types = prefs?.propertyTypes ?? [];
  const minBedrooms = prefs?.minBedrooms ?? 0;

  // Calculate bounding box
  const latDelta = radius / 111;
  const lonDelta = radius / (111 * Math.cos(loc.latitude * Math.PI / 180));
  
  const minLat = loc.latitude - latDelta;
  const maxLat = loc.latitude + latDelta;
  const minLon = loc.longitude - lonDelta;
  const maxLon = loc.longitude + lonDelta;

  // Build database conditions
  const conditions = [
    eq(properties.status, 'active'),
    ne(properties.visibilityStatus, 'archived'),
    isNotNull(properties.latitude),
    isNotNull(properties.longitude),
    // Price filtering with type conversion
    gte(properties.price, priceMin.toString()),
    lte(properties.price, priceMax.toString()),
    // Bounding box with type conversion
    gte(properties.latitude, minLat.toString()),
    lte(properties.latitude, maxLat.toString()),
    gte(properties.longitude, minLon.toString()),
    lte(properties.longitude, maxLon.toString())
  ];

  // Optional filters
  if (minBedrooms > 0) {
    conditions.push(gte(properties.bedrooms, minBedrooms));
  }
  if (types.length > 0) {
    conditions.push(inArray(properties.propertyType, types));
  }

  // Single database query
  const candidateProps = await db
    .select()
    .from(properties)
    .where(and(...conditions));

  // Precise distance filtering
  return candidateProps.filter((p) => {
    const lat = parseFloat(p.latitude || '0');
    const lon = parseFloat(p.longitude || '0');
    if (isNaN(lat) || isNaN(lon)) return false;
    
    const dist = this.haversine(loc.latitude, loc.longitude, lat, lon);
    return dist <= radius;
  });
}

private haversine(lat1: number, lon1: number, lat2: number, lon2: number) {
  const R = 6371; // Earth's radius in km
  const dLat = ((lat2 - lat1) * Math.PI) / 180;
  const dLon = ((lon1 - lon2) * Math.PI) / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos((lat1 * Math.PI) / 180) *
    Math.cos((lat2 * Math.PI) / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}</code></pre>

    <h2>Performance Results</h2>

    <table class="performance-table">
      <thead>
        <tr>
          <th>Metric</th>
          <th>Before</th>
          <th>After</th>
          <th>Improvement</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Properties Fetched</td>
          <td>10,000+</td>
          <td>~50-200</td>
          <td>50-200x</td>
        </tr>
        <tr>
          <td>Network Transfer</td>
          <td>~5MB</td>
          <td>~100KB</td>
          <td>50x</td>
        </tr>
        <tr>
          <td>Response Time</td>
          <td>2-5s</td>
          <td>&lt;200ms</td>
          <td>10-25x</td>
        </tr>
        <tr>
          <td>Memory Usage</td>
          <td>~150MB</td>
          <td>~5MB</td>
          <td>30x</td>
        </tr>
      </tbody>
    </table>

    <h2>Key Takeaways</h2>

    <h3>1. Filter at the Source</h3>
    <p>Always push filtering logic as close to the data source as possible. Database engines are optimized for this—use them.</p>

    <h3>2. Understand Your Type System</h3>
    <p>PostgreSQL's <code>NUMERIC</code> type maps to strings in TypeScript. Type conversions aren't just formalities—they're requirements.</p>

    <h3>3. Bounding Box + Precise Distance</h3>
    <p>For geospatial queries, use a two-stage approach:</p>
    <ul>
      <li>Stage 1: Fast rectangular bounding box (database)</li>
      <li>Stage 2: Precise circular distance (application)</li>
    </ul>

    <h3>4. ORM Constraints Matter</h3>
    <p>Different ORMs have different query building patterns. With Drizzle, combine all conditions into a single <code>where(and(...conditions))</code> call.</p>

    <h3>5. Optimize for the Common Case</h3>
    <p>Most searches will have a small radius (5-10km). Optimizing for this case gives the best real-world performance.</p>

    <h2>Future Optimizations</h2>
    <p>For even better performance at scale, consider:</p>

    <ul>
      <li><strong>PostGIS Extension:</strong> Native geospatial indexing and queries</li>
      <li><strong>Spatial Indexes:</strong> R-tree or GiST indexes for coordinate columns</li>
      <li><strong>Caching:</strong> Redis cache for popular search areas</li>
      <li><strong>Database Partitioning:</strong> Partition by geographic regions</li>
      <li><strong>Pre-computed Grids:</strong> Divide areas into grid cells for faster lookups</li>
    </ul>

    <h2>Conclusion</h2>
    <p>This optimization transformed a feature from "unusably slow" to "production-ready" with a few strategic changes. The lesson? Modern web apps demand sub-second responses, and achieving that often means rethinking your data access patterns from the ground up.</p>

    <p>The real win isn't just the speed—it's building a foundation that scales. Whether you have 10,000 or 1,000,000 properties, this approach keeps searches fast and users happy.</p>

    <div class="footnote">
      <p>Have you optimized geospatial queries in your apps? What techniques worked for you? Feel free to reach out and share your experiences!</p>
    </div>
  </div>
</div>

</body>
</html>